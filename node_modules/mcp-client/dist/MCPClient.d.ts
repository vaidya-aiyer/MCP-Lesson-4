import { ClientOptions } from '@modelcontextprotocol/sdk/client/index.js';
import { LoggingLevel, Implementation, Progress, Tool, Resource, Prompt, CallToolResult, CompleteRequest, CompleteResult, ReadResourceRequest, ReadResourceResult, GetPromptRequest, GetPromptResult, ResourceTemplate } from '@modelcontextprotocol/sdk/types.js';
export { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import EventEmitter from 'events';
import { z } from 'zod';
import { StrictEventEmitter } from 'strict-event-emitter-types';

/**
 * Callback for progress notifications.
 */
type ProgressCallback = (progress: Progress) => void;
type RequestOptions = {
    /**
     * If set, requests progress notifications from the remote end (if supported). When progress notifications are received, this callback will be invoked.
     */
    onProgress?: ProgressCallback;
    /**
     * Can be used to cancel an in-flight request. This will cause an AbortError to be raised from request().
     */
    signal?: AbortSignal;
    /**
     * A timeout (in milliseconds) for this request. If exceeded, an McpError with code `RequestTimeout` will be raised from request().
     *
     * If not specified, `DEFAULT_REQUEST_TIMEOUT_MSEC` will be used as the timeout.
     */
    timeout?: number;
};
type LoggingMessageNotification = {
    [key: string]: unknown;
    level: LoggingLevel;
};
type MCPClientEvents = {
    loggingMessage: (event: LoggingMessageNotification) => void;
};
declare const MCPClientEventEmitterBase: {
    new (): StrictEventEmitter<EventEmitter, MCPClientEvents>;
};
declare class MCPClientEventEmitter extends MCPClientEventEmitterBase {
}
declare class MCPClient extends MCPClientEventEmitter {
    private client;
    private transports;
    constructor(clientInfo: Implementation, options?: ClientOptions);
    connect(options: {
        type: "sse";
        url: string;
    } | {
        type: "stdio";
        args: string[];
        command: string;
        env: Record<string, string>;
    }): Promise<void>;
    ping(options?: {
        requestOptions?: RequestOptions;
    }): Promise<null>;
    getAllTools(options?: {
        requestOptions?: RequestOptions;
    }): Promise<Tool[]>;
    getAllResources(options?: {
        requestOptions?: RequestOptions;
    }): Promise<Resource[]>;
    getAllPrompts(options?: {
        requestOptions?: RequestOptions;
    }): Promise<Prompt[]>;
    callTool<TResultSchema extends z.ZodType = z.ZodType<CallToolResult>, TResult = z.infer<TResultSchema>>(invocation: {
        name: string;
        arguments?: Record<string, unknown>;
    }, options?: {
        resultSchema?: TResultSchema;
        requestOptions?: RequestOptions;
    }): Promise<TResult>;
    complete(params: CompleteRequest["params"], options?: {
        requestOptions?: RequestOptions;
    }): Promise<CompleteResult>;
    getResource(params: ReadResourceRequest["params"], options?: {
        requestOptions?: RequestOptions;
    }): Promise<ReadResourceResult>;
    getPrompt(params: GetPromptRequest["params"], options?: {
        requestOptions?: RequestOptions;
    }): Promise<GetPromptResult>;
    getAllResourceTemplates(options?: {
        requestOptions?: RequestOptions;
    }): Promise<ResourceTemplate[]>;
    setLoggingLevel(level: LoggingLevel): Promise<void>;
    close(): Promise<void>;
}

export { MCPClient };
