{"version":3,"sources":["../src/MCPClient.ts"],"sourcesContent":["import {\n  Client,\n  ClientOptions,\n} from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport {\n  CompleteRequest,\n  CompleteResult,\n  GetPromptRequest,\n  GetPromptResult,\n  Implementation,\n  ListPromptsResultSchema,\n  ListResourcesResultSchema,\n  ListToolsResultSchema,\n  LoggingLevel,\n  LoggingMessageNotificationSchema,\n  Progress,\n  Prompt,\n  ReadResourceRequest,\n  ReadResourceResult,\n  Resource,\n  ResourceTemplate,\n  Tool,\n  type CallToolResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport EventEmitter from \"events\";\nimport { z } from \"zod\";\nimport { StrictEventEmitter } from \"strict-event-emitter-types\";\nimport { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\n\nexport { ErrorCode, McpError } from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * Callback for progress notifications.\n */\ntype ProgressCallback = (progress: Progress) => void;\n\ntype RequestOptions = {\n  /**\n   * If set, requests progress notifications from the remote end (if supported). When progress notifications are received, this callback will be invoked.\n   */\n  onProgress?: ProgressCallback;\n  /**\n   * Can be used to cancel an in-flight request. This will cause an AbortError to be raised from request().\n   */\n  signal?: AbortSignal;\n  /**\n   * A timeout (in milliseconds) for this request. If exceeded, an McpError with code `RequestTimeout` will be raised from request().\n   *\n   * If not specified, `DEFAULT_REQUEST_TIMEOUT_MSEC` will be used as the timeout.\n   */\n  timeout?: number;\n};\n\nconst transformRequestOptions = (requestOptions: RequestOptions) => {\n  return {\n    onprogress: requestOptions.onProgress,\n    signal: requestOptions.signal,\n    timeout: requestOptions.timeout,\n  };\n};\n\ntype LoggingMessageNotification = {\n  [key: string]: unknown;\n  level: LoggingLevel;\n};\n\ntype MCPClientEvents = {\n  loggingMessage: (event: LoggingMessageNotification) => void;\n};\n\nconst MCPClientEventEmitterBase: {\n  new (): StrictEventEmitter<EventEmitter, MCPClientEvents>;\n} = EventEmitter;\n\nclass MCPClientEventEmitter extends MCPClientEventEmitterBase {}\n\nasync function fetchAllPages<T>(\n  client: any,\n  requestParams: { method: string; params?: Record<string, any> },\n  schema: any,\n  getItems: (response: any) => T[],\n  requestOptions?: RequestOptions,\n): Promise<T[]> {\n  const allItems: T[] = [];\n  let cursor: string | undefined;\n\n  do {\n    // Clone the params to avoid modifying the original object\n    const params = { ...(requestParams.params || {}) };\n\n    // Add cursor to params if it exists\n    if (cursor) {\n      params.cursor = cursor;\n    }\n\n    // Make the request\n    const response = await client.request(\n      { method: requestParams.method, params },\n      schema,\n      requestOptions ? transformRequestOptions(requestOptions) : undefined,\n    );\n\n    // Use the getter function to extract items\n    allItems.push(...getItems(response));\n\n    // Update cursor for next iteration\n    cursor = response.nextCursor;\n  } while (cursor);\n\n  return allItems;\n}\n\nexport class MCPClient extends MCPClientEventEmitter {\n  private client: Client;\n  private transports: Transport[] = [];\n\n  constructor(clientInfo: Implementation, options?: ClientOptions) {\n    super();\n\n    this.client = new Client(clientInfo, options);\n\n    this.client.setNotificationHandler(\n      LoggingMessageNotificationSchema,\n      (message) => {\n        if (message.method === \"notifications/message\") {\n          this.emit(\"loggingMessage\", {\n            level: message.params.level,\n            ...(message.params.data ?? {}),\n          });\n        }\n      },\n    );\n  }\n\n  async connect(\n    options:\n      | { type: \"sse\"; url: string }\n      | {\n          type: \"stdio\";\n          args: string[];\n          command: string;\n          env: Record<string, string>;\n        },\n  ): Promise<void> {\n    if (options.type === \"sse\") {\n      const transport = new SSEClientTransport(new URL(options.url));\n\n      this.transports.push(transport);\n\n      await this.client.connect(transport);\n    } else if (options.type === \"stdio\") {\n      const transport = new StdioClientTransport({\n        command: options.command,\n        env: options.env,\n        args: options.args,\n      });\n\n      this.transports.push(transport);\n    } else {\n      throw new Error(`Unknown transport type`);\n    }\n  }\n\n  async ping(options?: { requestOptions?: RequestOptions }): Promise<null> {\n    await this.client.ping(options?.requestOptions);\n\n    return null;\n  }\n\n  async getAllTools(options?: {\n    requestOptions?: RequestOptions;\n  }): Promise<Tool[]> {\n    return fetchAllPages(\n      this.client,\n      { method: \"tools/list\" },\n      ListToolsResultSchema,\n      (result) => result.tools,\n      options?.requestOptions,\n    );\n  }\n\n  async getAllResources(options?: {\n    requestOptions?: RequestOptions;\n  }): Promise<Resource[]> {\n    return fetchAllPages(\n      this.client,\n      { method: \"resources/list\" },\n      ListResourcesResultSchema,\n      (result) => result.resources,\n      options?.requestOptions,\n    );\n  }\n\n  async getAllPrompts(options?: {\n    requestOptions?: RequestOptions;\n  }): Promise<Prompt[]> {\n    return fetchAllPages(\n      this.client,\n      { method: \"prompts/list\" },\n      ListPromptsResultSchema,\n      (result) => result.prompts,\n      options?.requestOptions,\n    );\n  }\n\n  async callTool<\n    TResultSchema extends z.ZodType = z.ZodType<CallToolResult>,\n    TResult = z.infer<TResultSchema>,\n  >(\n    invocation: {\n      name: string;\n      arguments?: Record<string, unknown>;\n    },\n    options?: {\n      resultSchema?: TResultSchema;\n      requestOptions?: RequestOptions;\n    },\n  ): Promise<TResult> {\n    return (await this.client.callTool(\n      invocation,\n      options?.resultSchema as any,\n      options?.requestOptions\n        ? transformRequestOptions(options.requestOptions)\n        : undefined,\n    )) as TResult;\n  }\n\n  async complete(\n    params: CompleteRequest[\"params\"],\n    options?: {\n      requestOptions?: RequestOptions;\n    },\n  ): Promise<CompleteResult> {\n    return await this.client.complete(params, options?.requestOptions);\n  }\n\n  async getResource(\n    params: ReadResourceRequest[\"params\"],\n    options?: {\n      requestOptions?: RequestOptions;\n    },\n  ): Promise<ReadResourceResult> {\n    return await this.client.readResource(params, options?.requestOptions);\n  }\n\n  async getPrompt(\n    params: GetPromptRequest[\"params\"],\n    options?: {\n      requestOptions?: RequestOptions;\n    },\n  ): Promise<GetPromptResult> {\n    return await this.client.getPrompt(params, options?.requestOptions);\n  }\n\n  async getAllResourceTemplates(options?: {\n    requestOptions?: RequestOptions;\n  }): Promise<ResourceTemplate[]> {\n    let cursor: string | undefined;\n\n    const allItems: ResourceTemplate[] = [];\n\n    do {\n      const response = await this.client.listResourceTemplates(\n        { cursor },\n        options?.requestOptions,\n      );\n\n      allItems.push(...response.resourceTemplates);\n\n      cursor = response.nextCursor;\n    } while (cursor);\n\n    return allItems;\n  }\n\n  async setLoggingLevel(level: LoggingLevel) {\n    await this.client.setLoggingLevel(level);\n  }\n\n  async close() {\n    for (const transport of this.transports) {\n      await transport.close();\n    }\n  }\n}\n"],"mappings":"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","names":[]}